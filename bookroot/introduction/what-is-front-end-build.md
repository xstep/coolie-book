# 什么是前端构建

我所理解的前端构建是这样的：

## 要构建哪些内容
构建工具只需要关心 html、css、js，及其引用的静态资源。

正如 [fis 官网](http://fis.baidu.com/fis3/docs/user-dev/extlang.html) 所说的：

> fis项目曾经历了很久的 “努力做好编译工具” 的时代，那段时间里，fis走了很多弯路，那时我们认为前端领域需要很复杂的编译工具才能很好的处理各种开发需求。2013年初，fis的编译工具非常庞大复杂，日益暴露出来的问题已经开始不再收敛了，这促使fis小组重新审视fis的编译系统： 满足前端开发需求的最小编译规则集是什么？

> 前端编译工具有必要那么复杂么？答案是 完全没必要！想象一下尺规作图，一把直尺，一只圆规，就可以做出很多基本几何操作。经过fis团队不断实践总结，我们发现支持前端开发所需要的编译能力 只有三种 ：

> - 资源定位：获取任何开发中所使用资源的线上路径；
> - 内容嵌入：把一个文件的内容(文本)或者base64编码(图片)嵌入到另一个文件中；
> - 依赖声明：在一个文本文件内标记对其他资源的依赖关系；

> 一套前端编译工具，只要实现上述3项编译能力，就可以变得非常易用，代码可维护性瞬间提高很多。

落地实现：

- JS 文件的分析、合并、压缩、版本管理
- CSS 文件的分析、合并、压缩、版本管理
- HTML 文件分析、压缩、版本管理
- 入口模块的分析、分块、合并、压缩、版本管理
- 静态资源的分析、压缩、版本管理


## 保证构建前后皆可运行
不要在构建规则里添加一些无法正常运行的东西，比如：

```
// js 引入 js
require('demo.js');

// js 引入 image
var img = require('images/logo.gif');

// js 引入 css
var css = require('a.css');
```

除非构建工具配套有一个特殊的运行环境，提供`require`方法。如果无法提供，那么就进入了预编译阶段了。
其实，预编译大多都是单文件直接编译即可，这样一来涉及到多文件、甚至是递归的编译，编译时间大大增加，
非常影响正常的开发。


## 不含预编译
不要把预编译混合进去（其实这一点和第 2 点差不多是雷同的），预编译有专门的工具，它们可以做的更好。比如：

- less 有 [less](https://www.npmjs.com/package/less)
- scss 有 [node-sass](https://www.npmjs.com/package/node-sass)
- es6 有 [babel](https://babeljs.io/)
- 等等


## 必须是工程化管理
前端构建工具，不是将一个文件处理好，然后由前端开发人员传送给后端人员，由它们将页面添加到工程里。
这么做话，前端构建工具，就是个炮灰，基本没什么作用，和你不构建就发给对方有什么区别？

一个前端工程，甚至是一个混合工程里，都应该包含两个路径，一个开发路径，一个生产路径：

```
.
|-- webroot-dev #开发环境的前端根目录
|-- webroot-pro #生产环境的前端根目录
```

在平时的开发过程中，只需要注意开发目录，甚至我们可以这样。

![](https://ooo.0o0.ooo/2015/09/04/55e947ffdfbbd.png)

构建之后，`webroot-pro`即为资源的根目录。


## 单命令通用化
如果一个前端构建，还需要下载安装各种不太认识的 plugin 来碰碰运气，还需要写一堆 JS 代码来协调各个
plugin 直接的协调工具，那么这个工具还是不足称之为构建工具，只能说是构建基础工具。
因为其本身无法完成，需要借助各种 plugin。比如 grunt、gulp、fis、webpack 等，都属于同一条战线。
正因为它们这种性质，它们更多的是充当编译工具。

比如 webpack 更多的是和 react、es6 搭配，将`require(es6)`编译成一段 es5 代码，
或者是打包一个模块化脚本。

如何将这些功能通用化，将配置做的彻底，能满足通用化的前端构建，
这才是一个构建工具需要完成的事情，而不是一股脑的将配置交给开发者来维护，提高开发者的入门成本，
加上参差不齐的 plugin、工具的版本升级等因素带来的利弊是相当可观的，又是一场维护上的灾难。


## 扩展能力
通用化，不是普适性。而是在通用化的基础上，开发一些扩展接口，具备高级扩展能力。


## 静态分析，与后端无关
因为大部分前端资源本身就是静态的，当前可以进行静态分析。对 html、css、js 的静态分析，
进行资源移动、整合、压缩、版本管理，而不是借助后端能力才能完成。比如：

```
<!--coolie-->
<link rel="stylesheet" href="1.css">
<link rel="stylesheet" href="2.css">
<link rel="stylesheet" href="3.css">
<link rel="stylesheet" href="4.css">
<!--/coolie-->

<!--coolie-->
<script src="1.js"></script>
<script src="2.js"></script>
<script src="3.js"></script>
<script src="4.js"></script>
<!--/coolie-->

=>

<link rel="stylesheet" href="/path/to/xxoo.css">
<script src="/path/to/xxoo.js"></script>
```

再比如 js 模块的依赖

```
define(function(require, exports, module){
    require('1.js');
    require('2.png', 'image');
    require('3.css', 'css');
    require('4.html', 'html');
});

=>

define('0', ['1', '2', '3', '4'], ...);
// 1 => 1.js
// 2 => 2.png
// 3 => 3.css
// 4 => 4.html
```

## 完善的模块构建
可以完成完善的模块构建功能，适应各种工程类型。
实现分块模块构建、异步模块构建，能够保证压缩后代码量最少。

![](http://s.ydr.me/@/res/20151106094453379163722220)
